# 文件拖拽获取文件路径实现说明

本项目实现了完整的文件拖拽功能，支持在Tauri桌面环境和Web浏览器环境下获取文件路径并打开文件。实现分为两个层面：**Tauri环境**和**Web环境**。

## 1. 整体架构

### 1.1 双环境支持
- **Tauri环境**：使用Tauri的原生拖拽事件监听，可直接获取系统文件路径
- **Web环境**：使用HTML5 Drag & Drop API，通过FileReader读取文件内容

### 1.2 核心文件
- `src/App.jsx` - 主应用组件，处理Web环境下的拖拽事件
- `src/hooks/useFileManager.jsx` - 文件管理Hook，处理Tauri环境下的拖拽监听
- `src/styles/drag-overlay.scss` - 拖拽视觉反馈样式

## 2. Tauri环境实现

### 2.1 配置启用
在 `src-tauri/tauri.conf.json` 中启用拖拽功能：

```json
{
  "app": {
    "windows": [
      {
        "dragDropEnabled": true
      }
    ]
  }
}
```

### 2.2 事件监听实现
在 `useFileManager.jsx` 中监听Tauri拖拽事件：

```javascript
import { listen } from '@tauri-apps/api/event'

// 监听文件拖拽放置事件
const unlistenFileDrop = listen('tauri://drag-drop', async (event) => {
    // 隐藏拖拽覆盖层
    window.dispatchEvent(new CustomEvent('tauri-drag-leave'));

    const { paths } = event.payload;
    if (Array.isArray(paths) && paths.length > 0) {
        for (const path of paths) {
            try {
                // 检查是否为目录
                const isDirectory = await fileApi.isDirectory(path);
                
                if (isDirectory) {
                    // 如果是目录，更新面包屑导航
                    window.dispatchEvent(new CustomEvent('update-breadcrumb', {
                        detail: { path }
                    }));
                } else {
                    // 如果是文件，直接打开
                    await handleFileOpen(path);
                }
            } catch (error) {
                // 错误处理：尝试作为文件打开
                try {
                    await handleFileOpen(path);
                } catch (fileError) {
                    console.error('Failed to open as file:', path, fileError);
                }
            }
        }
    }
})

// 监听拖拽进入事件
const unlistenDragEnter = listen('tauri://drag-enter', (_) => {
    window.dispatchEvent(new CustomEvent('tauri-drag-enter'));
})

// 监听拖拽离开事件  
const unlistenDragLeave = listen('tauri://drag-leave', (_) => {
    window.dispatchEvent(new CustomEvent('tauri-drag-leave'));
})
```

### 2.3 Tauri事件类型
- `tauri://drag-drop` - 文件放置事件，payload包含文件路径数组
- `tauri://drag-enter` - 拖拽进入窗口事件
- `tauri://drag-leave` - 拖拽离开窗口事件

## 3. Web环境实现

### 3.1 拖拽事件处理
在 `App.jsx` 中实现Web环境的拖拽处理：

```javascript
/**
 * 处理拖拽悬停事件
 */
const handleDragOver = useCallback((e) => {
    e.preventDefault();
    e.stopPropagation();
    
    if (!isDragOver) {
        setIsDragOver(true);
    }
}, [isDragOver]);

/**
 * 处理拖拽进入事件
 */
const handleDragEnter = useCallback((e) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragOver(true);
}, []);

/**
 * 处理拖拽离开事件
 */
const handleDragLeave = useCallback((e) => {
    e.preventDefault();
    e.stopPropagation();

    const rect = e.currentTarget.getBoundingClientRect();
    const x = e.clientX;
    const y = e.clientY;

    // 检查鼠标是否真正离开了拖拽区域
    if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
        setIsDragOver(false);
    }
}, []);
```

### 3.2 文件处理逻辑
```javascript
/**
 * 处理文件拖拽放置事件
 */
const handleDrop = useCallback(async (e) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragOver(false);

    const hasTauri = typeof window !== 'undefined' && window['__TAURI_INTERNALS__'] !== undefined;

    if (!hasTauri) {
        const files = Array.from(e.dataTransfer.files);

        if (files.length === 0) {
            return;
        }

        for (const file of files) {
            try {
                if (file.webkitRelativePath) {
                    // 处理文件夹拖拽
                    await fileManager.setOpenFile(file.webkitRelativePath);
                } else {
                    // 处理单个文件
                    let content;
                    let fileName = file.name;

                    try {
                        // 使用FileReader读取文件内容
                        content = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = (e) => resolve(e.target.result);
                            reader.onerror = (e) => reject(e);
                            reader.readAsText(file, 'UTF-8');
                        });

                        await fileManager.setOpenFile(fileName, content, {
                            encoding: 'UTF-8',
                            lineEnding: 'LF'
                        });
                    } catch (error) {
                        // 读取失败时创建空文件
                        console.error('Failed to read file:', error);
                        await fileManager.setOpenFile(fileName, '', {
                            encoding: 'UTF-8',
                            lineEnding: 'LF'
                        });
                    }
                }
            } catch (error) {
                console.error('Error processing file:', error);
            }
        }
    }
}, [fileManager]);
```

## 4. 视觉反馈实现

### 4.1 拖拽覆盖层
通过 `isDragOver` 状态控制拖拽覆盖层的显示：

```jsx
{isDragOver && (
    <div className="drag-overlay">
        <div className="drag-overlay-content">
            <div className="drag-icon">📁</div>
            <div className="drag-text">拖拽文件到此处</div>
            <div className="drag-subtext">支持多个文件同时拖拽</div>
        </div>
    </div>
)}
```

### 4.2 样式定义
在 `drag-overlay.scss` 中定义拖拽覆盖层样式：

```scss
.drag-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(24, 144, 255, 0.08);
  backdrop-filter: blur(4px);
  z-index: 9999;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  animation: fadeIn 0.2s ease-in-out;
}

.drag-overlay-content {
  background: rgba(255, 255, 255, 0.95);
  border: 2px dashed #1890ff;
  border-radius: 16px;
  padding: 48px 64px;
  text-align: center;
  box-shadow: 
    0 16px 48px rgba(24, 144, 255, 0.12),
    0 8px 24px rgba(0, 0, 0, 0.08);
  animation: scaleIn 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
  backdrop-filter: blur(8px);
  max-width: 400px;
}
```

## 5. 环境检测

### 5.1 Tauri环境检测
```javascript
const hasTauri = typeof window !== 'undefined' && window['__TAURI_INTERNALS__'] !== undefined;
```

### 5.2 处理逻辑分离
- **Tauri环境**：使用原生事件监听，直接获取文件系统路径
- **Web环境**：使用HTML5 API，通过FileReader读取文件内容

## 6. 文件类型处理

### 6.1 文件与目录区分
在Tauri环境中，通过 `fileApi.isDirectory(path)` 检查拖拽项是否为目录：
- **目录**：更新面包屑导航，不打开编辑器
- **文件**：直接在编辑器中打开

### 6.2 错误处理
```javascript
try {
    const isDirectory = await fileApi.isDirectory(path);
    if (isDirectory) {
        // 处理目录
    } else {
        // 处理文件
    }
} catch (error) {
    // 如果检查失败，尝试作为文件处理
    try {
        await handleFileOpen(path);
    } catch (fileError) {
        console.error('Failed to open as file:', path, fileError);
    }
}
```

## 7. 事件清理

### 7.1 Tauri事件清理
```javascript
return () => {
    unlistenOpenFile.then(fn => fn())
    unlistenFileDrop.then(fn => fn())
    unlistenDragEnter.then(fn => fn())
    unlistenDragLeave.then(fn => fn())
}
```

### 7.2 Web事件清理
通过React的useEffect清理机制自动处理DOM事件的移除。

## 8. 特性总结

### 8.1 支持的功能
- ✅ 单文件拖拽
- ✅ 多文件拖拽
- ✅ 目录拖拽（Tauri环境）
- ✅ 文件内容读取（Web环境）
- ✅ 视觉反馈
- ✅ 错误处理
- ✅ 双环境兼容

### 8.2 技术特点
- **跨平台兼容**：同时支持桌面和Web环境
- **原生性能**：Tauri环境下直接使用系统API
- **优雅降级**：Web环境下提供完整的文件读取功能
- **用户体验**：提供直观的拖拽视觉反馈
- **错误恢复**：完善的错误处理和回退机制

这种实现方式确保了应用在不同环境下都能提供一致且可靠的文件拖拽体验。